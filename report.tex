\documentclass[a4paper,11pt,twoside]{article}
%\documentclass[a4paper,11pt,twoside,se]{article}

\usepackage{UmUStudentReport}
\usepackage{verbatim}   % Multi-line comments using \begin{comment}
\usepackage{courier}    % Nicer fonts are used. (not necessary)
\usepackage{pslatex}    % Also nicer fonts. (not necessary)
%\usepackage{lmodern}   % Optional fonts. (not necessary)
%\usepackage{tabularx}
%\usepackage{microtype} % Provides some typographic improvements over default settings
%\usepackage{placeins}  % For aligning images with \FloatBarrier
%\usepackage{booktabs}  % For nice-looking tables
%\usepackage{titlesec}  % More granular control of sections.

% DOCUMENT INFO
% =============
\department{Institution f√∂r Datavetenskap}
\coursename{Datavetenskapens byggstenar 7.5 p}
\coursecode{DV160HT15}
\title{OU1 Testing}
\author{Lorenz Gerber  ({\tt{dv15lgr@cs.umu.se}})}
\date{2015-11-17}
%\revisiondate{2015-09-15}
\instructor{Lena Kallin Westin / Johan Eliasson}


% DOCUMENT SETTINGS
% =================
\bibliographystyle{plain}
%\bibliographystyle{ieee}
\pagestyle{fancy}
\raggedbottom
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\graphicspath{{images/}}   %Path for images

% DEFINES
% =======
%\newcommand{\mycommand}{<latex code>}


% DOCUMENT
% ========
\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Introduction} 
The aim of this laboration was to write unit test code for an
implementation of the data type `queue'. The unit tests shall 
return feedback to the user, indicating `success' or `failure'. The
interface of the datatype may not be changed. All operations given in
\cite[p. 155]{janlert2000} shall be tested.

\section{Material and Methods} 
The datatype `queue' was said to be implemented according to the 
specifications given in \cite[pp.155 -- 172]{janlert2000}. The
implementation was in `C' according to standard `C99'. I chose to 
implement the unit tests according to the axiomatic specification 
given in \cite[pp.156 + 157]{janlert2000}. The toolchain was clang, 
CMake 3.3.2, GDB 7.8, IDE was CLion 1.2.1. Valgrind was used to 
find memory leaks. Development platform was OSX 10.10. 

\section{Results}
\subsection{General}
The source code was stored in a file \texttt{queuetest.c} and submitted
according instructions on the `cambro' web interface. The unit tests were
all implemented as \texttt{void} functions taking no arguments. All function
output went to \texttt{stdout}. Each function outputs a short description of 
the tested operation. Depending on success, `pass' or `fail' is written
out. In case of `fail', the function exits and returns the value
\texttt{1}. All test functions are called from \texttt{main.c}. 
\subsection{Tests}
\begin{enumerate}
  \item Axiom 1, use \texttt{empty} to create an empty list and check
    with \texttt{isEmpty} if it is really emtpy. 
    \item Axiom 2, apply \texttt{enqueue} to an empty list and check
      that \texttt{isEmpty} returns \texttt{FALSE}.
      \item Axiom 3, if a queue q is empty, it follows that 
        consequtive \texttt{enqueue}, \texttt{dequeue} will result in
        the same queue q. 
        \item Axiom 4, if a queue q is not empty, it follows that
          \texttt{dequeue} and \texttt{enqueue} follow commutative
          properties, hence the resulting queue q will look the same
          independent in which sequence \texttt{dequeue} and 
          \texttt{enqueue} are applied.
          \item Axiom 5, if a queue q is empty, sequential
            application of \texttt{enqueue(v, q)} and
            \texttt{front(q)} will return \texttt{v}.
            \item Axiom 6, if a queue q is not empty,
              \texttt{enqueue} will not affect the next \texttt{front}
              operation. 
\end{enumerate}

\section{Discussion} 
\subsection{Dynamic memory handling in C}
The given implementation of queues with 2-cell uses dynamic memory
allocation in C. Memory handling functions are implemented. Therefore,
when comparing the outcome of two independent queues, two sets of data
have to be prepared. Operations such as \texttt{dequeue} will
deallocate dynamic memory hence the data will not be available for the
other queue operation. This was the case for Axiome 4 and 6.

\subsection{Application of unit tests to provided datatype}
The implemented unit tests where applied to the provided datatype
\texttt{queue} (implemented with a 2-cell list). Here, the unit tests 
all passed.

\subsection{Provoking unit test fails}
Several modifications on the given datatype were tested to provoke
unit test fails. Modifications were always tested on the whole chain
of unit tests. Each modifcation stated below was tested separate. 

\begin{enumerate}
\item Axiom 1, \texttt{isEmpty)} was modified to always 
return \texttt{FALSE}.
\item Axiom 2, \texttt{isEmpty} was modified to always
    return \texttt{TRUE}.
\item Axiom 3, in \texttt{enqueue} the function call
  to the list function was removed.
\item Axiom 4, in \texttt{dequeue}, the function call
  was modfied to show stack behaviour, entries were removed on the
  previous to last list position.
\item Axiom 5, in \texttt{front}, the function call
  was removed and instead the address to a hardcoded \texttt{int} value
  returned. This resulted in a compiler warning as a local stack
  variable was passed on. It worked however to provoke a fail for axiom
  5.
\item Axiom 6, for both \texttt{enqueue} and \texttt{dequeue} the
  position of action was changed: \texttt{enqueue} added at first list
  position, while \texttt{dequeue} removed the previous to last.
\end{enumerate} 

\subsection{Memory leaks}
Valgrind was used to detect and mend memory leaks, both in `pass' and `fail' cases.

\addcontentsline{toc}{section}{\refname}
\bibliography{references}

\end{document}
